
<div class="row">
  <div class="col-md-9">
    <article class="content" id="_content" data-uid="">
      <h1 id="" data-uid="">Data Delivery Insights</h1>
      
<h2 id="stream-hosts-foundational-premise-streaming-signals-for-event-intelligence">Stream Hosts Foundational Premise: Streaming Signals for Event Intelligence</h2>
<h3 id="back-to-basics">Back to Basics</h3>
<p>The premise of a Stream Host is to ingest streaming signals as messages into the Data Stream.</p>
<p>The premise for a Data Stream is the capability to ingest a fire hose and achieve the desired outcome even if not all the data elements are delivered. Consider how this contrasts with an ETL system.</p>
<p>Neither has a primary goal of guaranteed delivery.</p>
<h3 id="what-this-means">What this means</h3>
<p>If a value (e.g. a temperature reading) in the Data Stream is measured against a rule value and a call to action is created when a threshold is reached, there is no impact if the Data Stream misses some readings. These misses could occur for several reasons, one of which is buffering.</p>
<p>There are buffers in the Data Stream, but if they overflow and values are missed, the premise is intact.</p>
<p>In scenarios where multiple transactions occur concurrently, the Stream Host processes the first transaction and buffers the next. However, if the buffer reaches maximum capacity and another transaction is received, the Stream Host will drop the subsequent transaction to prevent potential bottlenecks.</p>
<h2 id="guaranteed-delivery--processing-files">Guaranteed Delivery – Processing Files</h2>
<p>There are circumstances where there needs to be a guarantee for the delivery of the data and the ‘dropping’ of data is unsuitable for the use case.  In these circumstances, the design should adopt a pattern that ensures auditable delivery.</p>
<h3 id="explanation">Explanation</h3>
<p>If there is a single batch, data is split into 80 separate messages by an agent within the Data Stream, however, the next agent processes the data significantly more slowly than the previous agent which causes buffering to occur, with 80 messages coming through almost immediately the SH is unable to buffer some messages and therefore drops them.</p>
<h3 id="recent-improvement">Recent Improvement</h3>
<p>The v4.4.0 release includes a Stream Host with superior &quot;buffer&quot; functionality.</p>
<p>The new <a href="https://app.gitbook.com/o/-MZASoMaVZCmWsNG58Xo/s/NrWOGXQC2OUEEXXok1fY/index.md">Window</a> Agent supports a delay in transmitting events to the next Agent in a Data Stream. This enhancement aims to mitigate the risk of excessive event data buffering within the Stream Host. The flow of events can be regulated to prevent potential overload scenarios, ensuring smoother data processing and system stability.</p>
<h2 id="data-stream-design-considerations-and-patterns">Data Stream Design Considerations and Patterns</h2>
<p>When discussing the Data Stream design there are other considerations that, by way of example, point to how patterns could be applied as the design depends on the data profile and orchestrating the data.</p>
<h3 id="not-all-ingested-messages-are-processed">Not all ingested messages are processed</h3>
<p>Introduce a mechanism to allocate batch IDs to ensure a message is processed. This relies on tracking individual messages outside the Data Stream (e.g. in a SQL table). If configured correctly, this can avoid duplication if a message is re-processed.</p>
<p>Another consideration could be to split the Data Stream and use storage (e.g. SQL) to process each message/record individually:</p>
<ul>
<li>Data Stream 1 ingests the message and saves it as a record in a table.</li>
<li>Data Stream 2 then processes each record row by row.</li>
</ul>
<h3 id="introduce-a-delay">Introduce a delay</h3>
<p>Introduce a delay in the Data Stream by including a “delay” Agent during processing to ensure messages are completely processed before a new message is received.</p>
<h3 id="small-polling-interval">Small polling interval</h3>
<p>When the polling interval of the listener is small (e.g. 5 or 10 seconds), the short time frame usually results in a Data Stream that is less performant.</p>
<p>Consider a longer polling interval.</p>
<p>A general observation is that when event intelligence monitors for asset failure, subject to certain use cases, a polling interval of 3600 seconds (i.e. one hour) is sufficient to timeously perceive degradation.</p>
<p><em>Meta tags: Data Stream.</em></p>

    
  <div class="last-modified">
    <hr />
    <p><small><em>Last modified: May 29, 2025</em></small></p>
  </div>
</article>
  </div>
  <div class="col-md-3">

    <div class="sidenav hide-when-search">
      <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
      <div class="sidetoggle collapse" id="sidetoggle">
        <div id="sidetoc"></div>
      </div>
    </div>
  </div>
</div>

<style>
  .page-description {
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--bs-border-color);
  }
  
  .page-description p {
    font-size: 1.1rem;
    line-height: 1.6;
    margin-bottom: 0;
    color: var(--bs-secondary-color);
  }
  
  /* Dark mode support */
  [data-bs-theme="dark"] .page-description p {
    color: var(--bs-secondary-color);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .page-description p {
      font-size: 1rem;
    }
  }
</style>

<script>
  // Hide descriptions that are just version numbers or dates
  document.addEventListener('DOMContentLoaded', function() {
    const descriptionElement = document.querySelector('.page-description p');
    if (descriptionElement) {
      const descriptionText = descriptionElement.textContent.trim();
      
      // Patterns to hide: version numbers (like "v4.4.0", "4.4.0"), dates (like "13 Mar 2024", "2024-03-13")
      const versionPattern = /^v?\d+\.\d+(\.\d+)?$/;
      const datePattern1 = /^\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}$/i;
      const datePattern2 = /^\d{4}-\d{2}-\d{2}$/;
      const datePattern3 = /^\d{2}\/\d{2}\/\d{4}$/;
      
      if (versionPattern.test(descriptionText) || 
          datePattern1.test(descriptionText) || 
          datePattern2.test(descriptionText) ||
          datePattern3.test(descriptionText)) {
        descriptionElement.parentElement.style.display = 'none';
      }
    }
  });
</script>